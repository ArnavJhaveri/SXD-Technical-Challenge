# -*- coding: utf-8 -*-
"""SXD Technical Challenge

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-7KOWYfqdDrafWhsP_gezT4KFoe_xqDW
"""

# Function class to define the function (coefficients and max/min) 
# and retrieve the optimal value from
class Function:
  def __init__(self, coeff_1, coeff_2, flag):
    self.coeff_1 = coeff_1
    self.coeff_2 = coeff_2
    self.flag = flag # true means max false means min
    self.opt = 0
  
  def set_opt(self, value):
    self.opt = value
  
  def get_opt(self):
    return self.opt

  def get_coeffs(self):
    return self.coeff_1, self.coeff_2

  def get_flag(self):
    return self.flag

  def value(self, x1, x2):
    return self.get_coeffs()[0] * x1 + self.get_coeffs()[1] * x2


# Constraint class to define a constraint (coefficients and whether <= or >=)
# and to check whether the constraint is passed given an input
class Constraint:
  def __init__(self, coeff_1, coeff_2, value, flag):
    self.coeff_1 = coeff_1
    self.coeff_2 = coeff_2
    self.value = value
    self.flag = flag # true means <= false means >=
  
  def get_value(self):
    return self.value

  def get_coeffs(self):
    return self.coeff_1, self.coeff_2
  
  def get_flag(self):
    return self.flag

  def check(self, x1, x2):
    if self.get_flag():
      return self.get_coeffs()[0] * x1 + self.get_coeffs()[1] * x2 <= self.get_value()
    return self.get_coeffs()[0] * x1 + self.get_coeffs()[1] * x2 > self.get_value()


# Variable class to hold the minimum and maximum allowed values given constraints
# and to retrieve that variables optimal value
class Variable:
  def __init__(self, constraint_1, constraint_2, var_number):
    self.min = 0
    if var_number == 1:
      self.max = int(min(constraint_1.get_value() / constraint_1.get_coeffs()[0], constraint_2.get_value() / constraint_2.get_coeffs()[0]))
    if var_number == 2:
      self.max = int(min(constraint_1.get_value() / constraint_1.get_coeffs()[1], constraint_2.get_value() / constraint_2.get_coeffs()[1]))
    self.opt = self.min
    
  def set_opt(self, value):
    self.opt = value

  def get_opt(self):
    return self.opt
  
  def get_min(self):
    return self.min

  def get_max(self):
    return self.max


# Function that solves the problem using a nested for loop and testing whether 
# max/min holds (if > or <) and updates optimal values accordingly
# Inputs: Function, Constraints (2), Variables (2)
# Return: 3-Tuple of (x1, x2, Z) optimal values
def solver(z, constraint_1, constraint_2, var_x1, var_x2):
  for x1 in range(var_x1.get_min(), var_x1.get_max() + 1):
    for x2 in range(var_x2.get_min(), var_x2.get_max() + 1):
      if (constraint_1.check(x1, x2) and constraint_2.check(x1, x2)):
        if (z.get_flag()):
          if z.get_opt() < z.value(x1, x2):
            z.set_opt(z.value(x1, x2))
            var_x1.set_opt(x1)
            var_x2.set_opt(x2)
        else:
          if z.get_opt() > z.value(x1, x2):
            z.set_opt(z.value(x1, x2))
            var_x1.set_opt(x1)
            var_x2.set_opt(x2)
  
  return var_x1.get_opt(), var_x2.get_opt(), z.get_opt()


# Defining objects for this question
z = Function(3, 4, True)
constraint_1 = Constraint(15, 10, 300, True)
constraint_2 = Constraint(2.5, 5, 110, True)
var_x1 = Variable(constraint_1, constraint_2, 1)
var_x2 = Variable(constraint_1, constraint_2, 2)

# Answer: (8, 18, 96)
print(solver(z, constraint_1, constraint_2, var_x1, var_x2))


# CHECK Q1 --> same answer of (4, 0, -12)
# z = Function(-3, 1, False)
# constraint_1 = Constraint(1, 2, 5, True)
# constraint_2 = Constraint(2, 1, 8, True)
# var_x1 = Variable(constraint_1, constraint_2, 1)
# var_x2 = Variable(constraint_1, constraint_2, 2)

# print(solver(z, constraint_1, constraint_2, var_x1, var_x2))